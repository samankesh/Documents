<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=mrl8jkM18OlOQN8JLgasD743Y1MyoXXu805C7ctTSjtd9tkGuUyeEpjpdMPlmbcX');ol.lst-kix_57hvl5ppyx4l-5.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-5 0}.lst-kix_57hvl5ppyx4l-8>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-8}ol.lst-kix_57hvl5ppyx4l-7.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-7 0}.lst-kix_57hvl5ppyx4l-5>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-5}.lst-kix_57hvl5ppyx4l-2>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-2}.lst-kix_57hvl5ppyx4l-0>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-0,decimal) ". "}.lst-kix_57hvl5ppyx4l-1>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-1,lower-latin) ". "}.lst-kix_57hvl5ppyx4l-7>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-7}.lst-kix_57hvl5ppyx4l-4>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-4}.lst-kix_57hvl5ppyx4l-2>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-2,lower-roman) ". "}ol.lst-kix_57hvl5ppyx4l-4.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-4 0}ol.lst-kix_57hvl5ppyx4l-1.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-1 0}.lst-kix_57hvl5ppyx4l-3>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-3,decimal) ". "}.lst-kix_57hvl5ppyx4l-5>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-5,lower-roman) ". "}.lst-kix_57hvl5ppyx4l-1>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-1}.lst-kix_57hvl5ppyx4l-4>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-4,lower-latin) ". "}.lst-kix_57hvl5ppyx4l-7>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-7,lower-latin) ". "}ol.lst-kix_57hvl5ppyx4l-6.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-6 0}.lst-kix_57hvl5ppyx4l-6>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-6,decimal) ". "}ol.lst-kix_57hvl5ppyx4l-7{list-style-type:none}.lst-kix_57hvl5ppyx4l-0>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-0}ol.lst-kix_57hvl5ppyx4l-8{list-style-type:none}.lst-kix_57hvl5ppyx4l-8>li:before{content:"" counter(lst-ctn-kix_57hvl5ppyx4l-8,lower-roman) ". "}ol.lst-kix_57hvl5ppyx4l-0{list-style-type:none}ol.lst-kix_57hvl5ppyx4l-1{list-style-type:none}ol.lst-kix_57hvl5ppyx4l-2.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-2 0}ol.lst-kix_57hvl5ppyx4l-2{list-style-type:none}ol.lst-kix_57hvl5ppyx4l-3.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-3 0}ol.lst-kix_57hvl5ppyx4l-3{list-style-type:none}ol.lst-kix_57hvl5ppyx4l-4{list-style-type:none}ol.lst-kix_57hvl5ppyx4l-5{list-style-type:none}ol.lst-kix_57hvl5ppyx4l-6{list-style-type:none}ol.lst-kix_57hvl5ppyx4l-8.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-8 0}.lst-kix_57hvl5ppyx4l-3>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-3}ol.lst-kix_57hvl5ppyx4l-0.start{counter-reset:lst-ctn-kix_57hvl5ppyx4l-0 0}.lst-kix_57hvl5ppyx4l-6>li{counter-increment:lst-ctn-kix_57hvl5ppyx4l-6}ol{margin:0;padding:0}table td,table th{padding:0}.c11{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#f3f3f3;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c10{background-color:#ffffff;color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Source Sans Pro";font-style:normal}.c9{background-color:#ffffff;color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Source Sans Pro";font-style:normal}.c8{background-color:#ffffff;color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.5pt;font-family:"Courier New";font-style:normal}.c7{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c21{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c20{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:12pt}.c13{background-color:#ffffff;color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Source Sans Pro";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Source Code Pro";font-style:normal}.c14{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c22{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c16{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c27{color:#000000;text-decoration:none;vertical-align:baseline;font-size:10.5pt;font-style:normal}.c6{border-spacing:0;border-collapse:collapse;margin-right:auto}.c19{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c23{font-size:10.5pt;font-family:"Courier New";font-weight:400}.c15{background-color:#ffffff;font-family:"Source Sans Pro";font-weight:400}.c26{padding:0;margin:0}.c30{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c28{color:inherit;text-decoration:inherit}.c24{margin-left:72pt;padding-left:0pt}.c4{font-weight:400;font-family:"Source Code Pro"}.c25{margin-left:36pt}.c2{height:0pt}.c17{font-size:16pt}.c18{background-color:#ffffff}.c29{font-size:26pt}.c5{height:12pt}.c12{font-size:12pt}.title{background-color:#ffffff;padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Source Sans Pro";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{background-color:#ffffff;padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{background-color:#ffffff;color:#000000;font-size:12pt;font-family:"Source Sans Pro"}p{background-color:#ffffff;margin:0;color:#000000;font-size:12pt;font-family:"Source Sans Pro"}h1{background-color:#ffffff;padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Source Sans Pro";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{background-color:#ffffff;padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Source Sans Pro";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{background-color:#ffffff;padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Source Sans Pro";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{background-color:#ffffff;padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Source Sans Pro";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{background-color:#ffffff;padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Source Sans Pro";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{background-color:#ffffff;padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Source Sans Pro";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c18 c30"><p class="c14 title" id="h.kg04rfwge637"><span class="c13 c29">Flattening Nested Many-to-Many Relationships in XML Files</span></p><h1 class="c20" id="h.rourdnjz9n2"><span class="c10">Introduction</span></h1><p class="c16"><span class="c18 c23"><br></span><span class="c15 c12">In most of the 2000&#39;s, XML was a widely used semi-structured format for data storage. It has since declined in popularity to other formats such as JSON but there are use cases for parsing XML today far more often than one might think.<br>The most obvious use case is for processing historical XML files (yes! 15-20 year old data) but there are still many systems that output XML files for logs among other things.<br><br>The use case covered in this document is for compressed (bz2) XML formatted files. Specifically, these files are </span><span class="c19 c15 c12"><a class="c28" href="https://www.google.com/url?q=http://xml.coverpages.org/naxml.html&amp;sa=D&amp;ust=1557435695602000">NAXML</a></span><span class="c15 c12">&nbsp;which was a common format for transaction logs coming from convenien</span><span>ce</span><span class="c15 c12">&nbsp;store or gas station cash registers. </span><span class="c12">&nbsp;</span><span class="c15 c12">The hardware that produces these logs may not be upgraded for decades, such as the pumps at a gas station; hence, it is still common to come across newly generated NAXML files</span><span>. P</span><span class="c15 c12">arsing them into a structured optimal format like Parquet is the first step for success for most intended use cases of the data down the line.</span><span class="c12">&nbsp; </span><span class="c15 c12">Despite XML being more complicated to parse than other formats such as JSON, there is a chance you or your business will have to parse historic NAXML files or new log files from old hardware producing NAXML files.</span><span class="c12">&nbsp; </span><span class="c15 c12">This document serves to present a special use case of parsing such XML files with nested transactional data.<br><br>First, the raw data is described to show the various nuances of the data structure. </span><span class="c12">&nbsp;</span><span class="c15 c12">Second, the difficulties in processing the data in a distributed system is laid out.</span><span class="c12">&nbsp; </span><span class="c12 c15">Finally, the implemented solution is presented and limitations are discussed.</span></p><h1 class="c20" id="h.2wmxkoxuxl2f"><span>Raw Data Files</span></h1><p class="c16"><span class="c12 c18">A typical file is structured in the following nested object structure:</span><span class="c8"><br></span></p><a id="t.04bfef2d19b5636b90627a0cd45c67fec9f11a61"></a><a id="t.0"></a><table class="c6"><tbody><tr class="c2"><td class="c11" colspan="1" rowspan="1"><p class="c3"><span class="c23">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c4 c27">&lt;NAXML-POSJournal&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TransmissionHeader&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TransmissionID&gt;1234567890&lt;/TransmissionID&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Date&gt;2018-10-30&lt;/Date&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Time&gt;13:26:05&lt;/Time&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Status&gt;OK&lt;/Status&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TransmissionDetails&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tag_type_1&gt;...&lt;tag_type_1&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tag_type_2&gt;...&lt;tag_type_2&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tag_type_1&gt;...&lt;tag_type_1&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TransmissionDetails&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TransmissionHeader &gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;JournalReport&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ReportHeader&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... Header Details and Nested Structure<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ReportHeader&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SaleEvent&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TransactionID&gt;X123456789&lt;/TransactionID&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;DetailGroup&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Tender&gt;&lt;/Tender&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Customer&gt;&lt;/Customer&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/DetailGroup&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/SaleEvent&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SaleEvent&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TransactionID&gt;X987654321&lt;/TransactionID&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;DetailGroup&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LineItem&gt;...&lt;/LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LineItem&gt;...&lt;/LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/DetailGroup&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/SaleEvent&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;FinancialEvent&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;DetailGroup&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Account&gt;...&lt;/Account&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Customer&gt;...&lt;/Customer&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/LineItem&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/DetailGroup&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/FinancialEvent&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/JournalReport &gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/NAXML-POSJournal&gt;</span></p></td></tr></tbody></table><p class="c0"><span class="c8"></span></p><p class="c16"><span><br>Each file has a single main tag; in this case the </span><span class="c4">`NAXML-POSJournal`</span><span>&nbsp;tag. Each file is produced by a single piece of hardware for a specific time duration. This information is contained in the </span><span class="c4">`TransmissionHeader`</span><span>&nbsp;tag.<br><br>Further, all of the transactional data is contained within the </span><span class="c4">`JournalReport`</span><span>&nbsp;tag. Each transaction event is an object in the </span><span class="c4">`JournalReport`</span><span>&nbsp;and can be one of multiple possible tags such as </span><span class="c4">`SaleEvent`</span><span>&nbsp;or </span><span class="c4">`FinancialEvent`</span><span>&nbsp;as well as many more. Any number of each type of event within the parent </span><span class="c4">`JournalReport`</span><span>&nbsp;is acceptable. &nbsp;Similarly, each one of the event tags may have any nested objects structure inside with no consistency across different tags. &nbsp; For example, the </span><span class="c4">`JournalReport`</span><span>&nbsp;is equivalent to an </span><span class="c4">Array[Array([String, String])]</span><span>&nbsp;where each instance of the internal </span><span class="c4">Array[String, String]</span><span>&nbsp;is of random sizes and keys.<br><br>To demonstrate this point further, both </span><span class="c4">`SaleEvent`</span><span>&nbsp;and </span><span class="c4">`FinancialEvent`</span><span>&nbsp;have a `</span><span class="c4">DetailGroup</span><span>` tag which is an array of `</span><span class="c4">LineItem</span><span class="c13 c12">` but the contained line items have different tags nested inside. This nested pattern is present across the entire file with an unknown depth. &nbsp;Looking at such a file can quickly feel like a bird&#39;s nest in circuits or spaghetti code. If the file is accompanied by an XSD, it is much easier to comprehend both the structure and give much insight into the proposed solution. &nbsp;An XSD file describes the nested structure of the data and can be used to determine object hierarchy which is the inspiration of this proposed solution; to flatten the data into the way the XSD file is flattened. More on this soon!</span></p><p class="c0"><span class="c13 c12"></span></p><h1 class="c20" id="h.2vwivdz6agiv"><span class="c10">The Distributed Problem</span></h1><p class="c16"><span>Before discussion of the problems in distributed processing of these NAXML files, it is important to note that there are many XML parsing libraries in all modern languages to process such files. The problem becomes of how to process thousands or millions of these files in an efficient manner using a Spark cluster. <br><br>At first glance, it might seem trivial to parse this file using Apache Spark. After all, Spark has a native XML parser and one could create the underlying *schema* using StructType, MapType and ArrayType to match the nested objects inside every file. A few attempts at this and it becomes clear that it is impossible to define a schema that allows us to capture all the nested objects since the depth is unknown; this is discussed in the </span><span class="c19"><a class="c28" href="#h.vjgwdmc182wq">Limitations of the Spark XML Parser</a></span><span class="c13 c12">&nbsp;section below.<br><br>Moving away from the actual parsing of the XML, there is also the problem of reading of the file content by a Spark cluster. &nbsp;To parse the content of the file correctly, every opening tag must be matched with a closing tag to ensure a properly formatted XML file. This means that a file cannot be read partially by any one executor in the cluster. &nbsp;This problem is much more complicated to solve and the proposed solution does not present a viable option for partially reading in the XML file; hence allowing a file to be read partially by multiple executors.<br></span></p><h1 class="c20" id="h.vjgwdmc182wq"><span>Limitations of the </span><span class="c19"><a class="c28" href="https://www.google.com/url?q=https://github.com/databricks/spark-xml&amp;sa=D&amp;ust=1557435695606000">Spark XML Parser</a></span></h1><p class="c16"><span>Even if a schema to accommodate the nested structure could be constructed, the existing Spark XML parser is unable to process this file. &nbsp;The Spark XML Parser is very simple and designed for a very narrow use case. In short, it expects a consistent and repeated structure that it can parse into rows of StructType. &nbsp;For example, a root tag, which could be `</span><span class="c4">ReportJournal</span><span>`, with potentially the row tag as each row of events but since the events don&#39;t have a consistent `</span><span class="c4">rowTag</span><span>` this option does little to return a dataframe of rows. &nbsp;It would be ideal to be able to define a rowTag as an interface of *</span><span class="c4">EventType</span><span>* where `</span><span class="c4">SalesEvent</span><span>` and `</span><span class="c4">FinancialEvent</span><span>` all implement the interface. &nbsp;The only way this would work (which it still wouldn&#39;t) is if the schema of `</span><span class="c4">rowTag</span><span>` was a very large flattened structure of all the various unique &quot;keys&quot; in all implementations of the *</span><span class="c4">EventType</span><span>* interface so the output row is a </span><span class="c4">StructType</span><span class="c13 c12">&nbsp;that contains every possible key of all objects.<br></span></p><h1 class="c20" id="h.8ni43kne32jv"><span class="c10">The Solution</span></h1><p class="c16"><span>As alluded to earlier, the solution uses the structure of the XSD to create a complete map of every file&#39;s content flattened. Using a relational database model approach, every distinct &quot;tag&quot; type is defined as a table, every instance of the tag type is inserted as a row and given a unique key as well as a foreign key as to which tag it was nested in. &nbsp;As the XML structure is traversed recursively, the parent-child relationship is clear. &nbsp;The result is a series of dataframes, one for each tag type representing a &quot;table&quot; of rows.<br><br>It&#39;s important to note that there is an obscure distinction here, the &quot;table&quot; concept is defined for every distinct tag is that NOT a leaf node. Simply put, if a tag does not nest any tags inside of it, it is assumed that either the tag&#39;s inner text or attributes are desired as columns of the parent tag.<br><br>For example:</span><span><br></span></p><a id="t.6f99c066980508cec49501a957a6c3ae8c4da11a"></a><a id="t.1"></a><table class="c6"><tbody><tr class="c2"><td class="c11" colspan="1" rowspan="1"><p class="c3"><span class="c1"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;user inSchool=&quot;True&quot;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;Billie&lt;/name&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;age&gt;10&lt;/age&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;hobbies&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;hobby&gt;fishing&lt;/hobby&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;hobby&gt;hunting treasure&lt;/hobby&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;hobby&gt;training to be a pirate&lt;/hobby&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/hobbies&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/user&gt;<br></span></p></td></tr></tbody></table><p class="c0"><span class="c8"></span></p><p class="c16"><span><br>In the example above, both the tags `</span><span class="c4">user</span><span>` and `</span><span class="c4">hobbies</span><span>` would become a distinct dataframe while `</span><span class="c4">inSchool</span><span>`, `</span><span class="c4">name</span><span>`, `</span><span class="c4">age</span><span>`, and `</span><span class="c4">hobbies</span><span class="c13 c12">` would be column names in the parent tag&#39;s dataframe. The above example would result in the dataframes below:<br></span></p><p class="c0"><span class="c8"></span></p><a id="t.f100da2eff960ae072e6870a7e53fce9fc9f1c56"></a><a id="t.2"></a><table class="c6"><tbody><tr class="c2"><td class="c11" colspan="1" rowspan="1"><p class="c3"><span class="c1"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;users_df.collect()</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|--------------- user ---------------|</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;PK &nbsp;| &nbsp;inSchool &nbsp;| &nbsp;name &nbsp;| &nbsp;age &nbsp;|</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|------|------------|--------|-------|</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|1 &nbsp; &nbsp; |True &nbsp; &nbsp; &nbsp; &nbsp;|Billie &nbsp;|10 &nbsp; &nbsp; |</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|------------------------------------|</span></p><p class="c3 c5"><span class="c1"></span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;hobbies_df.collect()</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|---------------------- hobbies ---------------------|</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;PK &nbsp;| &nbsp;FK &nbsp;| &nbsp;FK_Object &nbsp;| hobby &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|------|------|-------------|------------------------|</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|1 &nbsp; &nbsp; |1 &nbsp; &nbsp; |user &nbsp; &nbsp; &nbsp; &nbsp; |fishing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|2 &nbsp; &nbsp; |1 &nbsp; &nbsp; |user &nbsp; &nbsp; &nbsp; &nbsp; |hunting treasure &nbsp; &nbsp; &nbsp; &nbsp;|</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|3 &nbsp; &nbsp; |1 &nbsp; &nbsp; |user &nbsp; &nbsp; &nbsp; &nbsp; |training to be a pirate |</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|----------------------------------------------------|<br></span></p></td></tr></tbody></table><p class="c0"><span class="c8"></span></p><p class="c0"><span class="c12 c13"></span></p><p class="c16"><span>Finally, there is no guarantee that every tag of type `</span><span class="c4">user</span><span>` will have the attribute `</span><span class="c4">inSchool</span><span class="c13 c12">` defined at all. In order to create consistency, it is expected that all attributes and tags to be processed and recorded must be defined as a type of schema of sorts.<br><br>In the simple example above, a data dictionary such as below must be defined.<br></span></p><p class="c0"><span class="c8"></span></p><a id="t.d3881d036bf1adaad5f36045bada6865dc7e5f9d"></a><a id="t.3"></a><table class="c6"><tbody><tr class="c2"><td class="c11" colspan="1" rowspan="1"><p class="c3"><span class="c1"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema = {</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;user&quot;: [</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;inSchool&quot;,</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;,</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;age&quot;</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hobbies&quot;: [</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hobby&quot;,</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;a_non_existing_tag&quot;</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br></span></p></td></tr></tbody></table><p class="c16"><span><br>With the above dictionary, every key is expected to be a table/dataframe with a primary key and every list is the columns for that table. &nbsp; If something is omitted, such as name or </span><span class="c4">inSchool</span><span>, it is left out of the final table. Alternatively, if a field is defined that does not exist, such as &#39;</span><span class="c4">a_non_existing_tag&#39;</span><span>, it is still defined as a column with the same name in the final table and filled in with `</span><span class="c4">Null</span><span class="c13 c12">` values.<br><br>This logic ensures that all rows of the table &quot;hobbies&quot; or &quot;user&quot; are consistent in schema. The current solution expects this dictionary to be pre-defined. If an XSD is given, this dictionary can be automatically created from parsing the XSD; however, this is out of scope for this document.</span></p><h1 class="c20" id="h.l31fptngfrx4"><span class="c10">The implementation</span></h1><p class="c16"><span class="c13 c12">The implementation follows the logic below:<br></span></p><ol class="c26 lst-kix_57hvl5ppyx4l-0 start" start="1"><li class="c7"><span class="c13 c12">Each file is read as a wholeTextFile.</span></li></ol><ol class="c26 lst-kix_57hvl5ppyx4l-1 start" start="1"><li class="c16 c24"><span class="c13 c12">This is important so we can parse the file at once to ensure it is not corrupt.</span></li><li class="c16 c24"><span class="c13 c12">All tags in the file must be given a foreign key matching the outer parent tag.</span></li></ol><p class="c0"><span class="c13 c12"></span></p><ol class="c26 lst-kix_57hvl5ppyx4l-0" start="2"><li class="c7"><span class="c13 c12">Each child is traversed recursively starting at the root.</span></li></ol><p class="c0"><span class="c13 c12"></span></p><ol class="c26 lst-kix_57hvl5ppyx4l-0" start="3"><li class="c7"><span class="c13 c12">A primary key is generated for the node</span></li></ol><p class="c0 c25"><span class="c13 c12"></span></p><ol class="c26 lst-kix_57hvl5ppyx4l-0" start="4"><li class="c7"><span class="c13 c12">For every node, the attributes are defined as columns for itself and inserted as one row.</span></li></ol><p class="c0"><span class="c13 c12"></span></p><ol class="c26 lst-kix_57hvl5ppyx4l-0" start="5"><li class="c7"><span class="c13 c12">For every node, the node&#39;s tag name is defined as a column in the parent and the text content is inserted as a row.</span></li><li class="c7"><span class="c13 c12">The parent&#39;s primary key is saved for the node as a foreign key</span></li></ol><p class="c0"><span class="c13 c12"></span></p><h2 class="c21" id="h.z7d5hio9b362"><span class="c13 c17">Parsing Logic</span></h2><p class="c16"><span class="c13 c12">An RDD of the directory of XML files is read and every file is parsed resulting in an RDD of one row per file; this ensures an entire file is processed at once on one executor. If that row is lost, it must be calculated all over again ensuring that the foreign key to primary key relationship of the nested tags is respected.</span></p><p class="c0"><span class="c8"></span></p><a id="t.3ca29dbe968a1cd702ed1acab49d1639e607ee42"></a><a id="t.4"></a><table class="c6"><tbody><tr class="c2"><td class="c11" colspan="1" rowspan="1"><p class="c3"><span class="c1"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from pyspark.sql import functions as f</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parser = XMLParser(data_dictionary)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_rdd = spark.sparkContext.wholeTextFiles(directory).map(parser.parseAll)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spark</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.createDataFrame(file_rdd)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.write</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.format(&quot;parquet&quot;)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.mode(&quot;overwrite&quot;)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.option(&quot;compression&quot;, &quot;snappy&quot;)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.save(file_location)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type_dfs = {}</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for dataType in data_dictionary:</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp_df = spark.read.parquet(file_location).select(f.explode(dataType).alias(&quot;tmp&quot;))</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exploded_cols = [&quot;tmp.{}&quot;.format(col) for col in tmp_df.select(f.explode(&quot;tmp&quot;)).select(&quot;key&quot;).distinct().rdd.flatMap(lambda x: x).collect()]</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_dfs[dataType] = tmp_df.select(exploded_cols).alias(dataType)</span></p><p class="c3 c5"><span class="c1"></span></p><p class="c3 c5"><span class="c1"></span></p></td></tr></tbody></table><p class="c16"><span><br><br>The each row of this RDD has a Row() object with a key for file name, and a key for every tag type parsed as per the data dictionary supplied. Using the &quot;user&quot; example above, the Row() object has the keys `</span><span class="c4">user</span><span>` and `</span><span class="c4">hobbies</span><span class="c13 c12">` and both user and hobbies are an array of dictionaries.<br><br>This RDD is converted to a dataframe and saved as is. This is basically a checkpoint. If there is a loss of data on write, an entire row would have to be recalculated resulting in consistent primary and foreign keys as expressed earlier. &nbsp;The second step is to re-read the data and explode each of the data types into it&#39;s own dataframe. Since one file may contain 1 user and another file 5 users, the explode returns a &quot;user&quot; dataframe with 6 rows. &nbsp;The final output is a dictionary of dataframes.</span></p><h2 class="c21" id="h.62xy3krjqhct"><span class="c13 c17">The Parsing Object</span></h2><p class="c0"><span class="c8"></span></p><a id="t.65ad2a7c6e1520d8565c46bc4de0d89ab29515d9"></a><a id="t.5"></a><table class="c6"><tbody><tr class="c2"><td class="c11" colspan="1" rowspan="1"><p class="c3"><span class="c1"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import xml.etree.ElementTree as ET</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from pyspark.sql import Row</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from pyspark.sql.types import *</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import datetime</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import random</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import hashlib</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class XMLParser():</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self, data_dictionary):</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._xml_data_dictionary = data_dictionary</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def parseAll(self, file):</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; timestamp = datetime.datetime.now()</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; file_name = file[0]</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; xml_string = file[1].encode(&#39;utf-8&#39;)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; root = ET.fromstring(xml_string)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; output = {}</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; def processChild(elem, parent_guid, parent_tag):</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem_tag = remove_tag_namespace(elem.tag)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generated_elem_guid = get_guid(timestamp, file_name, elem.tag)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_data = {</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;PK_{}&quot;.format(elem_tag): generated_elem_guid,</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;FK_OBJECT&quot;: parent_tag,</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;FK_ID&quot;: parent_guid,</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;FILE_NAME&quot;: file_name,</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;PROCESS_TS&quot;: str(timestamp),</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;CORRUPT_RECORD&quot;: &quot;&quot;</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Filling in the attributes from the element</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # NOTE: This loop does the job of filling in None for all the values we care about</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for potential_attribute in self._xml_data_dictionary[elem_tag]:</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_data[potential_attribute] = elem.get(potential_attribute, None)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for child in list(elem):</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_tag = remove_tag_namespace(child.tag)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((len(child) == 0) and</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (elem_tag in self._xml_data_dictionary) and</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (child_tag in self._xml_data_dictionary[elem_tag])):</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_data[child_tag] = child.text</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process_child(child, generated_elem_guid, elem_tag)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if elem_tag not in self._xml_data_dictionary:</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # We shouldn&#39;t need this fill_missing_cols anymore</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # but leaving in for further testing</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ready_data = fill_missing_cols(elem_data, elem_tag)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output[elem_tag].append(ready_data)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; def fill_missing_cols(data, type_name):</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for required_col in self.config[type_name]:</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if required_col not in data:</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; data[required_col] = &quot;Null&quot;</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; def remove_tag_namespace(tag_string):</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if &#39;}&#39; not in tag_string:</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tag_string</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return tag_string.split(&#39;}&#39;, 1)[1]</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; def get_guid(a,b,c):</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val_string = &quot;{}_{}_{}_{}&quot;.format(a, b, c, random.randint(1,999999999))</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hashlib.sha224(val_string).hexdigest()</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processChild(root, None, None)</span></p><p class="c3"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; return Row(**output)</span></p><p class="c3 c5"><span class="c1"></span></p><p class="c3 c5"><span class="c1"></span></p></td></tr></tbody></table><p class="c16"><span><br><br>The parsing is done using the native Python XML library. It is worthy to note that Python identifies the library with security vulnerabilities such as injection attacks. The entire file string is parsed into a traversable XML object immediately. Starting at the root node, all nodes are traversed recursively.<br><br>The function `</span><span class="c4">processChild</span><span>` starts at the given node, then creates a dictionary for the current node (which becomes a row in the node&#39;s respective table), fills in the keys and values as per the defined schema and continues to perform a depth first recursion. &nbsp;The namespace of the XML tags are removed as namespacing creates often difficult to read large strings; however, it is noted that if namespacing is needed, the `</span><span class="c4">remove_tag_namespace</span><span class="c13 c12">` function can be bypassed.<br></span></p><h2 class="c21" id="h.gc7xgxcqxan6"><span class="c13 c17">The GUID Generation</span></h2><p class="c16"><span class="c13 c12">The primary key is defined as a SHA-224 hash using the timestamp the executor began processing the file, the filename, the node&#39;s tagname, and a randomly generated number.<br>The idea here is that if two executors process the same file, at the exact same moment, then each tag would still get a unique key based on the random number generated. There is a chance for collision but it is assumed to be acceptable. &nbsp;Given multiple executors can process the same file for redundancy, it is expected that this wouldn&#39;t happen at the exact same timestamp and in the case that it does, the machines random number generators would not give the same number. &nbsp;This is a topic for future improvement.<br></span></p><h3 class="c22" id="h.obngwlw8vs01"><span class="c9">Limitations</span></h3><p class="c16"><span>The biggest limitation of this solution is the requirement to read `</span><span class="c4">wholeTextFiles</span><span class="c13 c12">`. &nbsp;Since XML can have a great deal of repetition, compressed files on disk do not represent an accurate size of the actual file in memory. This can lead to high memory requirements and make the process prone to failure due to memory limitations if files are inconsistent in content/size.<br><br>Second, given a file must be processed by one executor in one pass to ensure consistent primary and foreign keys, the first step does not achieve true parallelism. The best performance would come from having enough executors as a factor of the number of files (10000 files with 100 executors?). Performance when 100 very large files are processed by 100 executors cannot be increased by scaling the cluster.<br><br></span></p><h2 class="c21" id="h.x5zu0jyf8o1h"><span class="c13 c17">Future upgrades<br></span></h2><h3 class="c22" id="h.iczrma8omv3t"><span class="c9">Using the XSD</span></h3><p class="c16"><span class="c13 c12"><br>As mentioned, the data dictionary supplied to the parser object can be defined and created based on an XSD file.<br></span></p><h3 class="c22" id="h.ugadumk0wcqy"><span class="c9">Very Large Individual Files</span></h3><p class="c16"><span class="c13 c12">There are alternative XML parsing libraries in Python that allow for parsing of XML in chunks instead of having to read the entire file into memory. &nbsp;This can be taken advantage of for parsing very large files across multiple executors alleviating the requirement to read wholeTextFiles. In this case, an alternative GUID generation logic should be used, perhaps, using only filenames and ensuring all filenames are unique within a batch.<br></span></p><h2 class="c21" id="h.ix3gghaqdlgt"><span class="c13 c17">Conclusion</span></h2><p class="c16"><span class="c13 c12"><br>This XML parser is an alternative approach to Spark&#39;s native XML parser given its limitations. <br>There are equal but different limitations with this approach. &nbsp;The intent here is to suggest the methodology, logic, and thinking when shifting to the paradigm of parallel processing with a concrete example and a prototype.</span></p><p class="c0"><span class="c13 c12"></span></p></body></html>